Middlewares - handle on coming before, after - after to create response

MINIMAL EXAMPLES FOR E2E to understand logic 

ubuntu 22.04 has gcc+11 which is unpropriately old for co_await async in cpp 20, so we need 24.04, which has builtin gcc 13-14+

```
[PROMPT FOR GPT / CONTEXT UPDATE] POST-MORTEM: C++20 Coroutines ASan bad-free issue resolved. Symptom: ASan reported attempting free on address which was not malloc()-ed in the destructor of std::string (_M_dispose -> delete). The crash occurred when a background thread (boost::asio::thread_pool) was destroying a lambda captured and offloaded from a C++20 coroutine (boost::asio::awaitable). The ASan trace explicitly showed that the memory being freed was located inside the coroutine frame (boost::asio::detail::awaitable_frame_base::operator new). Root Cause (Compiler Bug): The issue was a known code-generation bug in GCC 11 (related to PR 99576 / PR 100473) regarding lambda captures inside coroutines. An SSO-optimized std::string (length 8 bytes) was captured by value/move into a lambda within the coroutine. Instead of properly invoking the move/copy constructor for the closure, GCC 11 emitted a bitwise copy (memcpy). Consequently, the internal data pointer of the captured string still pointed to the SSO buffer of the original string, which resided strictly inside the coroutine frame. When the background thread destroyed the lambda, the captured string's destructor evaluated its internal pointer. Since the pointer did not match its own local SSO buffer address, it incorrectly assumed the string was heap-allocated and called delete on the coroutine frame's memory address. (This same compiler bug also previously caused use-after-free on std::shared_ptr control blocks due to bypassed copy constructors and unincremented ref counters). Resolution: Upgraded the compiler toolchain from GCC 11 to GCC 14. GCC 14 correctly generates the AST, properly invokes move constructors for lambda captures within coroutine frames, and correctly handles SSO lifetimes. Architectural State & Directive: All temporary workarounds (manual functor structs, forced std::move into local variables before co_await) have been removed. The original architecture is fully restored and verified: DI object lifetimes are strictly correct. async_offload implementation with std::shared_ptr captures is thread-safe and correct. Tests pass cleanly under strictly configured ASan + UBSan without any suppressions. Directive for future responses: Acknowledge that the core infrastructure (DI, Offload pattern, Coroutine lifetime management) is sound and verified. Stop suggesting architectural memory leaks, race conditions, or "masked UB" for this module. Focus strictly on new business logic and higher-level framework features.
```